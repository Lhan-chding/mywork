# 思考题
1.如果要使用范围比较大，一般可以用标签选择器进行一些通用的设置，（比如全文的颜色，字的大小之类的）。如果我想要一个标签上去套用几个选择器来实现不同的效果，那么就可以选择类选择器进行复用。（这种使用的在我的代码里面特别特别・多）如果要让专一的标签实现一个效果，那么使用id选择器最合适了，因为每个标签的id必须是唯一的。如果想要特殊的效果呈现，那么使用伪类选择器进行自定义非常简便。

2.<1> 绝对定位 absolute+外边距负值margin.

<2> 各个方向距离都设为零，然后margin: auto；（以上两种需要知道子元素的宽高）

<3> 使用transform：-50% 但是有个别浏览器不支持，而且当出现很多transform的时候可能干扰效果呈现。

<4>text-align: center 只对文本有用。

3.<1>固定布局： 给要设置布局的块元素直接利用元素width、height、margin、padding来设置块元素布局位置。或者是使用固定定位fixed,元素脱离文档流之后，设置top、right、bottom、left以及z-index(分层）。

<2>流动布局：和上一个的差距就在于测量的单位不同，固定布局使用px，而流动布局使用百分比的形式。

<3> 弹性盒子：flex使用的是轴线布局，针对项目关于轴线的位置改变。Grid是使用的行列划分成单元格，然后指定出项目（关于容器的顶层子元素）所在的单元格，通过display：grid可以实现网格的效果。（同时容器元素默认是块状元素，但可以通过inline-grid设置成行内元素。接着可以通过grid-template-columns和grid-template-rows来定义列宽和行高。（可以用px或者是%）。接着可以使用minmax长度范围，auto关键字，gap间距，grid-auto-flow顺序属性（默认先行后列），grid-area指定项目放置位置 等进行详细的设置。

4.因为不同分别率的手机对一个网站打开的呈现方式会不同，意味着如果我们不对其进行适配，那么可能导致我们在手机上的网页显示达不到预期的效果。或出现元素混淆意外覆盖等的错误。使用@media媒体查询针对不同分辨率设置不同的样式。Screen用于电脑屏幕，，手机，平板。然后通过最小和最大宽度来进行限制和改变。比如@media screen and (min-width: 300px){ 意思就是最大宽度小于等于300px的时候就应用花括号里面的样式，以此来避免差别。

5.有 string number Boolean null（空） undefined（未定义） object(对象) array（数组） function（函数），与其他语言不同，js里面不区分数值和浮点值，所有数字都是用64位浮点值来表示。在js里面字符串可以用单引号或者双引号括起来。Js里面没有单个字符的“字符型，要表示单个字符只需要将其赋值给字符串变量就行了。（这个新字符串的长度将是一）。Js有一个非常特殊的原始值null，用来描述空值，这也是其他语言所没有的。

6.<1> typeof:可以测试出number string Boolean undefined function。但是却不能区分出null，数组，对象。(这几种都会返回一个object属性)

<2> instanceof：可以左边放你要判断的内容，右边放类型来进行JS类型判断，只能用来判断复杂数据类型,因为instanceof 是用于检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。

<3> Object.prototype.toString.call 在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。但是它不能检测非原生构造函数的构造函数名.

<4> 还可以使用constructor，但是它不能判断undefined和null，并且使用它不安全因为contructor指向是可以被改变的。

7和8.

   <1> css无法根据元素之间的相对位置来找出某个特定元素，而dom可以。只需要把（if判断是否为那个特定函数）和（for循环进行一个一个元素往下切换）结合起来定义在一个大函数里面，接着嵌套几个小函数，中间用return进行反复就行。

<2> css无法反复设置样式，而dom可以。而且当一个表格非常大的时候，如果我们想更改其中的某一行或者某一列的时候，如果使用css，那么就需要更改大量的class，但如果我们使用dom进行操作的话，我们只需要通过构建一个函数，在函数里面先取得所有的列或者行，然后通过for循环进行判断和取值。就可以轻轻松松的找到我们需求的那一行。

 <3>对于响应事件来说，我们一般只要可以都采用css的方式去进行。因为css毕竟更加简单简便去写出，相对应来说dom的代码和结构会更加复杂一点。比如使用css的伪类选择器（但是伪类选择器有一个缺陷，并不是所有的浏览器都能够支持伪类选择器，这个时候我们再考虑使用js dom）

****总的来说，css是最常用的，是最简便的，大部分属性采用css最为方便，dom用来增强文档，同时当css设置某些标记变得困难的时候，dom再发挥作用。所以我更偏向于dom，因为可以让我的效果更好，能让我的网站功能更强大。

9.子元素的应该会先发生。因为所有事件的顺序是：其他元素捕获阶段事件 -> 本元素代码顺序事件 -> 其他元素冒泡阶段事件 。点击子元素，触发的父元素事件如果你采用的是事件冒泡，所以应当是子元素事件先发生，然后再发生父元素事件。相反如果你采用的是事件捕获，那么顺序相反，应该是父元素先被触发。因为微软开发的冒泡型是自下而上（ep：p->div->body->html->document）而网景提出的事件捕获是自上而下（document->html->body->div->p）。

 10.这是因为虽然js是单线程的，但是浏览器不是，浏览器在内部有着许多的线程，比如（渲染引擎线程（负责页面的渲染），js引擎（也就是负责js的解析和执行），定时触发器线程（负责定时事件），事件触发线程（负责处理DOM事件），异步http请求线程（处理http请求）。当同步执行（也就是依次执行任务）执行到某一个webAPI（即异步任务）时，就会触发异步操作（也就是将浏览器事件，定时器等单独开其他的线程去处理，也就是我们所看到的所谓的同时进行，异步任务里面也分优先级，被划分成了微任务(micro task)和宏任务(macri task）)js就会跳过这些代码，去执行后续代码。同时通过callback queue可以将执行完异步任务所得到的结果进行回调（另外通过event loop 在同步任务执行完毕的基础上（通过js引擎里面的monitoring process 进程来搜寻主程序执行是否为空为空立即去callback queue 里面检查是否有等待被调用的函数）不断的读取回调队列里面的回调函数，让所有异步任务的结果都能被得到）。

11.被追踪的文件不会被忽略掉，因为git ignore 只能忽略掉原来那些没有被跟踪的文件，如果某个文件已经被纳入了版本管理，那么使其被忽略的操作是无效的。

12.如果只是在本地进行了多次提交commit但是还没有提交到远端的话，那么可以使用git reset Chard解决（在hard后面加上你想要到达的id）但是这是一种强制操作。如果想稍微进行一下保留后面的工作目录和index暂存区代码，可以使用git reset Csoft（它只会把index 暂存区和repository 中的内容更改和reset目标节点一致。而原节点和reset之间的差异都会被放到工作目录working tree里面。）如果是commit已经提交到了远端，可以使用git revert来反做出你想要的那个版本。（ep：git revert -e<commit_id>:重做指定commit的提交信息  git revert -n<commit_id>:重做执行commit的代码修改）

13.因为reset会彻底清除提交后面的所有内容，如果我们突然发现后面的一部分代码还是有用的，（特别是在实际的生活生产中很容易出现这种情况）所以如果使用reset则就没有更改的机会了，这种没有退路的方式显然不会被经常使用。
